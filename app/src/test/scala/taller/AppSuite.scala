  /*
  * This Scala Testsuite was generated by the Gradle 'init' task.
  */
  package taller

  import org.scalatest.funsuite.AnyFunSuite
  import org.junit.runner.RunWith
  import org.scalatestplus.junit.JUnitRunner

  @RunWith(classOf[JUnitRunner])
  class AppSuite extends AnyFunSuite {
  test("App has a greeting") {
    assert(App.greeting() != null)
  }
  val cd = new ConjuntosDifusos

  }

@RunWith(classOf[JUnitRunner])
class ConjuntosDifusosTest extends AnyFunSuite {

  val cd = new ConjuntosDifusos
  val Vacio: cd.ConjDifuso = _ => 0.0
  val universal: cd.ConjDifuso = _ => 1.0
  val testecito: cd.ConjDifuso = (x: Int) => if (x <= 5) 1.0 else 0.0

//_____________________________________________________________________________________________________________________
//            TEST PERTENECE
//  = 1 PERTENECE    //////   = 0 NO PERTENECE

  test("[NO PERTENECE A UN CONJUNTO VACIO]") {

    assert(cd.pertenece(5, Vacio) == 0.0)
    assert(cd.pertenece(100, Vacio) == 0.0)
  }

  test("[PERTENECE A UN CONJUNTO UNIVERSAL DE NUMEROS]") {
    assert(cd.pertenece(5, universal) == 1.0)
    assert(cd.pertenece(100, universal) == 1.0)
  }

  test("[PERTENECE O NO PERTENECE Al CONJUNTO DIFUSO TESTECITO :D ]") {
    assert(cd.pertenece(2, testecito) == 1.0) // pertenece totalmente
    assert(cd.pertenece(7, testecito) == 0.0) // no pertenece
  }
  test("PERTENECE CON UN GRADO DE PERTENENCIA PARCIAL 0.5") {
    val medio: cd.ConjDifuso = _ => 0.5
    assert(cd.pertenece(10, medio) == 0.5)
  }
  test("PERTENECE A UN CONJUNTO DE NUMEROS PARES") {
    val pares: cd.ConjDifuso =
      (x: Int) =>
        if (x % 2 == 0)
          1.0
        else
          0.0
    assert(cd.pertenece(4, pares) == 1.0)
    assert(cd.pertenece(7, pares) == 0.0)
  }
  test("PERTENECE EN UN GRADO PARCIAL 0.8 ") {
    val Ochenta: cd.ConjDifuso = _ => 0.8
    assert(cd.pertenece(15, Ochenta) == 0.8)
    assert(cd.pertenece(200, Ochenta) == 0.8)
  }

// ============================================
//         TEST GRANDE
//  = 1.0 belongs to grande  //////   = 0.0 not belongs to grande
// ============================================

  test("Grande works with negative numbers and return 0.0") {
    val setDifuse1 = cd.grande(10)(2)

    assert(setDifuse1(-5) == 0.0)
  }

  test("Grande demonstrate larger numbers are higher than small numbers") {
    val setDifuse1 = cd.grande(10)(2)

    assert(setDifuse1(50) < setDifuse1(100))
  }

  test("Grande demonstrate that parameter 'd' controls the function") {
    val setDifuse1 = cd.grande(5)(2)
    val setDifuse2 = cd.grande(20)(2)

    assert(setDifuse1(50) > setDifuse2(50))
  }

  test("Grande shows the exact calculation for n=50 with a small possibility of error") {
    val setDifuse1 = cd.grande(10)(2)
    val expectedValue50 = math.pow(50.0 / 60.0, 2.0)

    assert(math.abs(setDifuse1(50) - expectedValue50) < 0.001)
  }

  test("Grande shows the exact calculation for n=100 with a small possibility of error") {
    val setDifuse1 = cd.grande(10)(2)
    val expectedValue100 = math.pow(100.0 / 110.0, 2.0)

    assert(math.abs(setDifuse1(100) - expectedValue100) < 0.001)
  }


//_____________________________________________________________________________________________________________________
//           TEST COMPLEMENTO
//  = 1 PERTENECE A CONJUNTO COMPLEMENTARIO  //////   = 0 NO PERTENECE AL CONJUNTO COMPLEMENTARIO

  test("COMPLEMENTO DE UN CONJUNTO VACIO") {
    val vacio: cd.ConjDifuso = _ => 0.0
    val comp = cd.complemento(vacio)

    assert(comp(1) == 1.0)
    assert(comp(50) == 1.0)
    }

  test("COMPLEMENTO DE UN CONJUNTO UNIVERSAL") {
    val universal: cd.ConjDifuso = _ => 1.0
    val comp = cd.complemento(universal)

    assert(comp(1) == 0.0)
    assert(comp(50) == 0.0)
    }
  test("COMPLEMENTO DEVUELVE EL VALOR ORIGINAL") {
    val comp = cd.complemento(testecito)
    val dobleComp = cd.complemento(comp)

    assert(dobleComp(3) == testecito(3))
    assert(dobleComp(10) == testecito(10))
    }
  test("COMPLEMENTO DE UN CONJUNTO CON GRADO 0.3") {
    val Treinta: cd.ConjDifuso = _ => 0.3
    val comp = cd.complemento(Treinta)

    assert(comp(1) == 0.7)
    assert(comp(100) == 0.7)
  }

  test("COMPLEMENTO DE UN CONJUNTO CON GRADO 0.5") {
    val medio: cd.ConjDifuso = _ => 0.5
    val comp = cd.complemento(medio)

    assert(comp(10) == 0.5)
    assert(comp(100) == 0.5)
  }

// ============================================
//         TEST UNION
// ============================================

  test("Union with empty set returns the other set") {
    val setDifuse1 = cd.grande(10)(2)
    val unionResult = cd.union(setDifuse1)(Vacio)

    assert(unionResult(50) == setDifuse1(50))
  }

  test("Union with universal set returns universal") {
    val setDifuse1 = cd.grande(10)(2)
    val unionResult = cd.union(setDifuse1)(universal)

    assert(unionResult(100) == 1.0)
  }

  test("Union is commutative example 1") {
    val setDifuse1 = cd.grande(10)(2)
    val setDifuse2 = cd.grande(20)(2)
    val unionResult1 = cd.union(setDifuse1)(setDifuse2)
    val unionResult2 = cd.union(setDifuse2)(setDifuse1)

    assert(unionResult1(50) == unionResult2(50))
  }

  test("Union is commutative example 2") {
    val setDifuse1 = cd.grande(10)(2)
    val setDifuse2 = cd.grande(20)(2)
    val unionResult1 = cd.union(setDifuse1)(setDifuse2)
    val unionResult2 = cd.union(setDifuse2)(setDifuse1)

    assert(unionResult1(73) == unionResult2(73))
  }

  test("Union takes maximum between two sets") {
    val setDifuse1 = cd.grande(5)(2)
    val setDifuse2 = cd.grande(20)(2)
    val unionResult = cd.union(setDifuse1)(setDifuse2)

    assert(unionResult(50) == math.max(setDifuse1(50), setDifuse2(50)))
  }

//__________________________________________________________________________________________________________
//           TEST  INTERSECCION
//   = 0 fuera de la intersecciÃ³n //// = 1 pertenece a ambos conjuntos

  test("NUNCA INTERSECCION CON VACIO") {
    val inter = cd.interseccion(testecito, Vacio)

    assert(inter(2) == 0.0)
    assert(inter(10) == 0.0)
  }

  test("INTERSECCION CON UNIVERSAL DA EL MISMO CONJUNTO") {
    val inter = cd.interseccion(testecito, universal)

    assert(inter(4) == testecito(4))
    assert(inter(25) == testecito(25))
  }

  test("INTERSECCION CON EL MISMO CONJUNTO DEVUELVE EL MISMO CONJUNTO") {
    val inter = cd.interseccion(testecito, testecito)

    assert(inter(30) == testecito(30))
    assert(inter(9) == testecito(9))
  }

  test("INTERSECCION MINIMO ENTRE DOS GRADOS") {
    val c1: cd.ConjDifuso = _ => 0.7
    val c2: cd.ConjDifuso = _ => 0.4
    val inter = cd.interseccion(c1, c2)
    assert(inter(5) == 0.4)
  }

  test("INTERSECCION GRADOS DIFERENTES") {
    val c1: cd.ConjDifuso = (x: Int) =>
      if (x < 10)
        0.8
      else
        0.3
    val c2: cd.ConjDifuso = (x: Int) =>
      if (x < 10)
        0.5
      else
        0.9
    val inter = cd.interseccion(c1, c2)

    assert(inter(5) == 0.5)
    assert(inter(15) == 0.3)
    }

// ============================================
//       TEST INCLUSION
// ============================================

  test("Inclusion shows that every set is included in the universal set") {
    val setDifuse1 = cd.grande(10)(2)

    assert(cd.inclusion(setDifuse1)(universal))
  }

  test("Inclusion shows that only empty set is included in empty set") {
    val setDifuse1 = cd.grande(10)(2)

    assert(!cd.inclusion(setDifuse1)(Vacio))
  }

  test("Inclusion shows that a small set is included in large set") {
    val smallNumbersSet = cd.grande(30)(2)
    val largeNumbersSet = cd.grande(5)(2)

    assert(cd.inclusion(smallNumbersSet)(largeNumbersSet))
  }

  test("Inclusion shows that is not commutative") {
    val smallNumbersSet = cd.grande(30)(2)
    val largeNumbersSet = cd.grande(5)(2)

    assert(!cd.inclusion(largeNumbersSet)(smallNumbersSet))
  }

  test("Inclusion shows that a set is included in itself") {
    val setDifuse1 = cd.grande(15)(2)

    assert(cd.inclusion(setDifuse1)(setDifuse1))
  }

//______________________________________________________________________
//              TEST IGUALDAD

  test("IGUALDAD A SI MISMO") {
    assert(cd.igualdad(testecito, testecito))
    assert(cd.igualdad(universal, universal))
    assert(cd.igualdad(Vacio, Vacio))
  }

  test("NO HAY IGUALDAD EN UNIVERSAL Y VACIO") {
    assert(!cd.igualdad(universal, Vacio))
  }

  test("NO HAY IGUALDAD EN TESTECITO Y UNIVERSAL") {
    assert(!cd.igualdad( testecito, universal))
  }

  test("DOS CONJUNTOS CON LA MISMA DEFINICION SON IGUALES") {
    val c1: cd.ConjDifuso = (x: Int) =>
      if (x < 20)
        0.7
      else
        0.2
    val c2: cd.ConjDifuso = (x: Int) =>
      if (x < 20)
        0.7
      else
        0.2

    assert(cd.igualdad(c1, c2))
  }

  test("CONJUNTOS CON GRADOS DIFERENTES NO SON IGUALES") {
    val c1: cd.ConjDifuso = _ => 0.5
    val c2: cd.ConjDifuso = _ => 0.8

    assert(!cd.igualdad(c1, c2))
  }
}